"""
NDI SDK for Python
"""

from __future__ import annotations
import numpy
import typing

__all__ = [
    "AudioFrameInterleaved16s",
    "AudioFrameInterleaved32f",
    "AudioFrameInterleaved32s",
    "AudioFrameV2",
    "AudioFrameV3",
    "FindCreate",
    "FindInstance",
    "FourCCAudioType",
    "FourCCVideoType",
    "FrameFormatType",
    "FrameSyncInstance",
    "FrameType",
    "MetadataFrame",
    "RECV_TIMESTAMP_UNDEFINED",
    "RecvBandwidth",
    "RecvColorFormat",
    "RecvCreateV3",
    "RecvInstance",
    "RecvPerformance",
    "RecvQueue",
    "RecvRecordingTime",
    "RoutingCreate",
    "RoutingInstance",
    "SEND_TIMECODE_SYNTHESIZE",
    "SendCreate",
    "SendInstance",
    "Source",
    "Tally",
    "VideoFrameV2",
    "destroy",
    "find_create_v2",
    "find_destroy",
    "find_get_current_sources",
    "find_wait_for_sources",
    "framesync_audio_queue_depth",
    "framesync_capture_audio",
    "framesync_capture_audio_v2",
    "framesync_capture_video",
    "framesync_create",
    "framesync_destroy",
    "framesync_free_audio",
    "framesync_free_audio_v2",
    "framesync_free_video",
    "initialize",
    "is_supported_CPU",
    "recv_add_connection_metadata",
    "recv_capture_v2",
    "recv_capture_v3",
    "recv_clear_connection_metadata",
    "recv_connect",
    "recv_create_v3",
    "recv_destroy",
    "recv_free_audio_v2",
    "recv_free_audio_v3",
    "recv_free_metadata",
    "recv_free_string",
    "recv_free_video_v2",
    "recv_get_no_connections",
    "recv_get_performance",
    "recv_get_queue",
    "recv_get_web_control",
    "recv_ptz_auto_focus",
    "recv_ptz_exposure_auto",
    "recv_ptz_exposure_manual",
    "recv_ptz_exposure_manual_v2",
    "recv_ptz_focus",
    "recv_ptz_focus_speed",
    "recv_ptz_is_supported",
    "recv_ptz_pan_tilt",
    "recv_ptz_pan_tilt_speed",
    "recv_ptz_recall_preset",
    "recv_ptz_store_preset",
    "recv_ptz_white_balance_auto",
    "recv_ptz_white_balance_indoor",
    "recv_ptz_white_balance_manual",
    "recv_ptz_white_balance_oneshot",
    "recv_ptz_white_balance_outdoor",
    "recv_ptz_zoom",
    "recv_ptz_zoom_speed",
    "recv_recording_get_error",
    "recv_recording_get_filename",
    "recv_recording_get_times",
    "recv_recording_is_recording",
    "recv_recording_is_supported",
    "recv_recording_set_audio_level",
    "recv_recording_start",
    "recv_recording_stop",
    "recv_send_metadata",
    "recv_set_tally",
    "routing_change",
    "routing_clear",
    "routing_create",
    "routing_destroy",
    "routing_get_no_connections",
    "send_add_connection_metadata",
    "send_capture",
    "send_clear_connection_metadata",
    "send_create",
    "send_destroy",
    "send_free_metadata",
    "send_get_no_connections",
    "send_get_source_name",
    "send_get_tally",
    "send_send_audio_v2",
    "send_send_audio_v3",
    "send_send_metadata",
    "send_send_video_async_v2",
    "send_send_video_v2",
    "send_set_failover",
    "util_P216_to_V210",
    "util_V210_to_P216",
    "util_audio_from_interleaved_16s_v2",
    "util_audio_from_interleaved_32f_v2",
    "util_audio_from_interleaved_32s_v2",
    "util_audio_to_interleaved_16s_v2",
    "util_audio_to_interleaved_32f_v2",
    "util_audio_to_interleaved_32s_v2",
    "util_send_send_audio_interleaved_16s",
    "util_send_send_audio_interleaved_32f",
    "util_send_send_audio_interleaved_32s",
    "version",
]

class AudioFrameInterleaved16s:
    no_channels: int
    no_samples: int
    reference_level: int
    sample_rate: int
    timecode: int
    def __init__(
        self,
        sample_rate: int = 48000,
        no_channels: int = 2,
        no_samples: int = 0,
        timecode: int = 9223372036854775807,
        reference_level: int = 0,
        p_data: int = 0,
    ) -> None: ...
    @property
    def data(self) -> numpy.ndarray: ...
    @data.setter
    def data(self, arg1: numpy.ndarray[numpy.int16]) -> None: ...

class AudioFrameInterleaved32f:
    no_channels: int
    no_samples: int
    sample_rate: int
    timecode: int
    def __init__(
        self,
        sample_rate: int = 48000,
        no_channels: int = 2,
        no_samples: int = 0,
        timecode: int = 9223372036854775807,
        p_data: float = 0,
    ) -> None: ...
    @property
    def data(self) -> numpy.ndarray: ...
    @data.setter
    def data(self, arg1: numpy.ndarray[numpy.float32]) -> None: ...

class AudioFrameInterleaved32s:
    no_channels: int
    no_samples: int
    reference_level: int
    sample_rate: int
    timecode: int
    def __init__(
        self,
        sample_rate: int = 48000,
        no_channels: int = 2,
        no_samples: int = 0,
        timecode: int = 9223372036854775807,
        reference_level: int = 0,
        p_data: int = 0,
    ) -> None: ...
    @property
    def data(self) -> numpy.ndarray: ...
    @data.setter
    def data(self, arg1: numpy.ndarray[numpy.int32]) -> None: ...

class AudioFrameV2:
    channel_stride_in_bytes: int
    metadata: str
    no_channels: int
    no_samples: int
    sample_rate: int
    timecode: int
    timestamp: int
    def __init__(
        self,
        sample_rate: int = 48000,
        no_channels: int = 2,
        no_samples: int = 0,
        timecode: int = 9223372036854775807,
        p_data: float = 0,
        channel_stride_in_bytes: int = 0,
        p_metadata: str = None,
        timestamp: int = 0,
    ) -> None: ...
    @property
    def data(self) -> numpy.ndarray: ...
    @data.setter
    def data(self, arg1: numpy.ndarray[numpy.float32]) -> None: ...

class AudioFrameV3:
    FourCC: FourCCAudioType
    channel_stride_in_bytes: int
    metadata: str
    no_channels: int
    no_samples: int
    sample_rate: int
    timecode: int
    timestamp: int
    def __init__(
        self,
        sample_rate: int = 48000,
        no_channels: int = 2,
        no_samples: int = 0,
        timecode: int = 9223372036854775807,
        FourCC: FourCCAudioType = ...,
        p_data: int = 0,
        channel_stride_in_bytes: int = 0,
        p_metadata: str = None,
        timestamp: int = 0,
    ) -> None: ...
    @property
    def data(self) -> numpy.ndarray: ...
    @data.setter
    def data(self, arg1: numpy.ndarray[numpy.uint8]) -> None: ...

class FindCreate:
    extra_ips: str
    groups: str
    show_local_sources: bool
    def __init__(self, show_local_sources: bool = True, p_groups: str = None, p_extra_ips: str = None) -> None: ...

class FindInstance:
    pass

class FourCCAudioType:
    """
    Members:

      FLTP

      MAX
    """

    FLTP: typing.ClassVar[FourCCAudioType]  # value = <FourCCAudioType.FLTP: 1884572742>
    MAX: typing.ClassVar[FourCCAudioType]  # value = <FourCCAudioType.MAX: 2147483647>
    __members__: typing.ClassVar[
        dict[str, FourCCAudioType]
    ]  # value = {'FLTP': <FourCCAudioType.FLTP: 1884572742>, 'MAX': <FourCCAudioType.MAX: 2147483647>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FourCCVideoType:
    """
    Members:

      UYVY

      UYVA

      P216

      PA16

      YV12

      I420

      NV12

      BGRA

      BGRX

      RGBA

      RGBX

      MAX
    """

    BGRA: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.BGRA: 1095911234>
    BGRX: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.BGRX: 1481787202>
    I420: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.I420: 808596553>
    MAX: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.MAX: 2147483647>
    NV12: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.NV12: 842094158>
    P216: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.P216: 909193808>
    PA16: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.PA16: 909197648>
    RGBA: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.RGBA: 1094862674>
    RGBX: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.RGBX: 1480738642>
    UYVA: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.UYVA: 1096178005>
    UYVY: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.UYVY: 1498831189>
    YV12: typing.ClassVar[FourCCVideoType]  # value = <FourCCVideoType.YV12: 842094169>
    __members__: typing.ClassVar[
        dict[str, FourCCVideoType]
    ]  # value = {'UYVY': <FourCCVideoType.UYVY: 1498831189>, 'UYVA': <FourCCVideoType.UYVA: 1096178005>, 'P216': <FourCCVideoType.P216: 909193808>, 'PA16': <FourCCVideoType.PA16: 909197648>, 'YV12': <FourCCVideoType.YV12: 842094169>, 'I420': <FourCCVideoType.I420: 808596553>, 'NV12': <FourCCVideoType.NV12: 842094158>, 'BGRA': <FourCCVideoType.BGRA: 1095911234>, 'BGRX': <FourCCVideoType.BGRX: 1481787202>, 'RGBA': <FourCCVideoType.RGBA: 1094862674>, 'RGBX': <FourCCVideoType.RGBX: 1480738642>, 'MAX': <FourCCVideoType.MAX: 2147483647>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FrameFormatType:
    """
    Members:

      PROGRESSIVE

      INTERLEAVED

      FIELD_0

      FIELD_1

      MAX
    """

    FIELD_0: typing.ClassVar[FrameFormatType]  # value = <FrameFormatType.FIELD_0: 2>
    FIELD_1: typing.ClassVar[FrameFormatType]  # value = <FrameFormatType.FIELD_1: 3>
    INTERLEAVED: typing.ClassVar[FrameFormatType]  # value = <FrameFormatType.INTERLEAVED: 0>
    MAX: typing.ClassVar[FrameFormatType]  # value = <FrameFormatType.MAX: 2147483647>
    PROGRESSIVE: typing.ClassVar[FrameFormatType]  # value = <FrameFormatType.PROGRESSIVE: 1>
    __members__: typing.ClassVar[
        dict[str, FrameFormatType]
    ]  # value = {'PROGRESSIVE': <FrameFormatType.PROGRESSIVE: 1>, 'INTERLEAVED': <FrameFormatType.INTERLEAVED: 0>, 'FIELD_0': <FrameFormatType.FIELD_0: 2>, 'FIELD_1': <FrameFormatType.FIELD_1: 3>, 'MAX': <FrameFormatType.MAX: 2147483647>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FrameSyncInstance:
    pass

class FrameType:
    """
    Members:

      NONE

      VIDEO

      AUDIO

      METADATA

      ERROR

      STATUS_CHANGE

      MAX
    """

    AUDIO: typing.ClassVar[FrameType]  # value = <FrameType.AUDIO: 2>
    ERROR: typing.ClassVar[FrameType]  # value = <FrameType.ERROR: 4>
    MAX: typing.ClassVar[FrameType]  # value = <FrameType.MAX: 2147483647>
    METADATA: typing.ClassVar[FrameType]  # value = <FrameType.METADATA: 3>
    NONE: typing.ClassVar[FrameType]  # value = <FrameType.NONE: 0>
    STATUS_CHANGE: typing.ClassVar[FrameType]  # value = <FrameType.STATUS_CHANGE: 100>
    VIDEO: typing.ClassVar[FrameType]  # value = <FrameType.VIDEO: 1>
    __members__: typing.ClassVar[
        dict[str, FrameType]
    ]  # value = {'NONE': <FrameType.NONE: 0>, 'VIDEO': <FrameType.VIDEO: 1>, 'AUDIO': <FrameType.AUDIO: 2>, 'METADATA': <FrameType.METADATA: 3>, 'ERROR': <FrameType.ERROR: 4>, 'STATUS_CHANGE': <FrameType.STATUS_CHANGE: 100>, 'MAX': <FrameType.MAX: 2147483647>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class MetadataFrame:
    data: str
    length: int
    timecode: int
    def __init__(self, length: int = 0, timecode: int = 9223372036854775807, p_data: str = None) -> None: ...

class RecvBandwidth:
    """
    Members:

      METADATA_ONLY

      AUDIO_ONLY

      LOWEST

      HIGHEST

      MAX
    """

    AUDIO_ONLY: typing.ClassVar[RecvBandwidth]  # value = <RecvBandwidth.AUDIO_ONLY: 10>
    HIGHEST: typing.ClassVar[RecvBandwidth]  # value = <RecvBandwidth.HIGHEST: 100>
    LOWEST: typing.ClassVar[RecvBandwidth]  # value = <RecvBandwidth.LOWEST: 0>
    MAX: typing.ClassVar[RecvBandwidth]  # value = <RecvBandwidth.MAX: 2147483647>
    METADATA_ONLY: typing.ClassVar[RecvBandwidth]  # value = <RecvBandwidth.METADATA_ONLY: -10>
    __members__: typing.ClassVar[
        dict[str, RecvBandwidth]
    ]  # value = {'METADATA_ONLY': <RecvBandwidth.METADATA_ONLY: -10>, 'AUDIO_ONLY': <RecvBandwidth.AUDIO_ONLY: 10>, 'LOWEST': <RecvBandwidth.LOWEST: 0>, 'HIGHEST': <RecvBandwidth.HIGHEST: 100>, 'MAX': <RecvBandwidth.MAX: 2147483647>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RecvColorFormat:
    """
    Members:

      BGRX_BGRA

      UYVY_BGRA

      RGBX_RGBA

      UYVY_RGBA

      FASTEST

      BEST

      E_BGRX_BGRA

      E_UYVY_BGRA

      E_RGBX_RGBA

      E_UYVY_RGBA

      BGRX_BGRA_FLIPPED

      MAX
    """

    BEST: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.BEST: 101>
    BGRX_BGRA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.BGRX_BGRA: 0>
    BGRX_BGRA_FLIPPED: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.BGRX_BGRA_FLIPPED: 1000>
    E_BGRX_BGRA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.BGRX_BGRA: 0>
    E_RGBX_RGBA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.RGBX_RGBA: 2>
    E_UYVY_BGRA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.UYVY_BGRA: 1>
    E_UYVY_RGBA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.UYVY_RGBA: 3>
    FASTEST: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.FASTEST: 100>
    MAX: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.MAX: 2147483647>
    RGBX_RGBA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.RGBX_RGBA: 2>
    UYVY_BGRA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.UYVY_BGRA: 1>
    UYVY_RGBA: typing.ClassVar[RecvColorFormat]  # value = <RecvColorFormat.UYVY_RGBA: 3>
    __members__: typing.ClassVar[
        dict[str, RecvColorFormat]
    ]  # value = {'BGRX_BGRA': <RecvColorFormat.BGRX_BGRA: 0>, 'UYVY_BGRA': <RecvColorFormat.UYVY_BGRA: 1>, 'RGBX_RGBA': <RecvColorFormat.RGBX_RGBA: 2>, 'UYVY_RGBA': <RecvColorFormat.UYVY_RGBA: 3>, 'FASTEST': <RecvColorFormat.FASTEST: 100>, 'BEST': <RecvColorFormat.BEST: 101>, 'E_BGRX_BGRA': <RecvColorFormat.BGRX_BGRA: 0>, 'E_UYVY_BGRA': <RecvColorFormat.UYVY_BGRA: 1>, 'E_RGBX_RGBA': <RecvColorFormat.RGBX_RGBA: 2>, 'E_UYVY_RGBA': <RecvColorFormat.UYVY_RGBA: 3>, 'BGRX_BGRA_FLIPPED': <RecvColorFormat.BGRX_BGRA_FLIPPED: 1000>, 'MAX': <RecvColorFormat.MAX: 2147483647>}
    def __and__(self, other: typing.Any) -> typing.Any: ...
    def __eq__(self, other: typing.Any) -> bool: ...
    def __ge__(self, other: typing.Any) -> bool: ...
    def __getstate__(self) -> int: ...
    def __gt__(self, other: typing.Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __invert__(self) -> typing.Any: ...
    def __le__(self, other: typing.Any) -> bool: ...
    def __lt__(self, other: typing.Any) -> bool: ...
    def __ne__(self, other: typing.Any) -> bool: ...
    def __or__(self, other: typing.Any) -> typing.Any: ...
    def __rand__(self, other: typing.Any) -> typing.Any: ...
    def __repr__(self) -> str: ...
    def __ror__(self, other: typing.Any) -> typing.Any: ...
    def __rxor__(self, other: typing.Any) -> typing.Any: ...
    def __setstate__(self, state: int) -> None: ...
    def __str__(self) -> str: ...
    def __xor__(self, other: typing.Any) -> typing.Any: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class RecvCreateV3:
    allow_video_fields: bool
    bandwidth: RecvBandwidth
    color_format: RecvColorFormat
    ndi_recv_name: str
    source_to_connect_to: Source
    def __init__(
        self,
        source_to_connect_to: Source = ...,
        color_format: RecvColorFormat = ...,
        bandwidth: RecvBandwidth = ...,
        allow_video_fields: bool = True,
        p_ndi_recv_name: str = None,
    ) -> None: ...

class RecvInstance:
    pass

class RecvPerformance:
    audio_frames: int
    metadata_frames: int
    video_frames: int
    def __init__(self) -> None: ...

class RecvQueue:
    audio_frames: int
    metadata_frames: int
    video_frames: int
    def __init__(self) -> None: ...

class RecvRecordingTime:
    last_time: int
    no_frames: int
    start_time: int
    def __init__(self) -> None: ...

class RoutingCreate:
    groups: str
    ndi_name: str
    def __init__(self, p_ndi_name: str = None, p_groups: str = None) -> None: ...

class RoutingInstance:
    pass

class SendCreate:
    clock_audio: bool
    clock_video: bool
    groups: str
    ndi_name: str
    def __init__(
        self, p_ndi_name: str = None, p_groups: str = None, clock_video: bool = True, clock_audio: bool = True
    ) -> None: ...

class SendInstance:
    pass

class Source:
    ndi_name: str
    url_address: str
    def __init__(self, p_ndi_name: str = None, p_url_address: str = None) -> None: ...

class Tally:
    on_preview: bool
    on_program: bool
    def __init__(self, on_program: bool = False, on_preview: bool = False) -> None: ...

class VideoFrameV2:
    FourCC: FourCCVideoType
    frame_format_type: FrameFormatType
    frame_rate_D: int
    frame_rate_N: int
    line_stride_in_bytes: int
    metadata: str
    picture_aspect_ratio: float
    timecode: int
    timestamp: int
    xres: int
    yres: int
    def __init__(
        self,
        xres: int = 0,
        yres: int = 0,
        FourCC: FourCCVideoType = ...,
        frame_rate_N: int = 30000,
        frame_rate_D: int = 1001,
        picture_aspect_ratio: float = 0.0,
        frame_format_type: FrameFormatType = ...,
        timecode: int = 0,
        p_data: int = 0,
        line_stride_in_bytes: int = 0,
        p_metadata: str = None,
        timestamp: int = 0,
    ) -> None: ...
    @property
    def data(self) -> numpy.ndarray: ...
    @data.setter
    def data(self, arg1: numpy.ndarray[numpy.uint8]) -> None: ...

def destroy() -> None: ...
def find_create_v2(create_settings: FindCreate = None) -> FindInstance: ...
def find_destroy(instance: FindInstance) -> None: ...
def find_get_current_sources(instance: FindInstance) -> list[Source]: ...
def find_wait_for_sources(instance: FindInstance, timeout_in_ms: int) -> bool: ...
def framesync_audio_queue_depth(instance: FrameSyncInstance) -> int: ...
def framesync_capture_audio(
    instance: FrameSyncInstance, sample_rate: int, no_channels: int, no_samples: int
) -> AudioFrameV2: ...
def framesync_capture_audio_v2(
    instance: FrameSyncInstance, sample_rate: int, no_channels: int, no_samples: int
) -> AudioFrameV3: ...
def framesync_capture_video(instance: FrameSyncInstance, field_type: FrameFormatType = ...) -> VideoFrameV2: ...
def framesync_create(receiver: RecvInstance) -> FrameSyncInstance: ...
def framesync_destroy(instance: FrameSyncInstance) -> None: ...
def framesync_free_audio(instance: FrameSyncInstance, audio_data: AudioFrameV2) -> None: ...
def framesync_free_audio_v2(instance: FrameSyncInstance, audio_data: AudioFrameV3) -> None: ...
def framesync_free_video(instance: FrameSyncInstance, video_data: VideoFrameV2) -> None: ...
def initialize() -> bool: ...
def is_supported_CPU() -> bool: ...
def recv_add_connection_metadata(instance: RecvInstance, metadata: MetadataFrame) -> None: ...
def recv_capture_v2(
    instance: RecvInstance, timeout_in_ms: int
) -> tuple[FrameType, VideoFrameV2, AudioFrameV2, MetadataFrame]: ...
def recv_capture_v3(
    instance: RecvInstance, timeout_in_ms: int
) -> tuple[FrameType, VideoFrameV2, AudioFrameV3, MetadataFrame]: ...
def recv_clear_connection_metadata(instance: RecvInstance) -> None: ...
def recv_connect(instance: RecvInstance, source: Source = None) -> None: ...
def recv_create_v3(create_settings: RecvCreateV3 = None) -> RecvInstance: ...
def recv_destroy(instance: RecvInstance) -> None: ...
def recv_free_audio_v2(instance: RecvInstance, audio_data: AudioFrameV2 = None) -> None: ...
def recv_free_audio_v3(instance: RecvInstance, audio_data: AudioFrameV3 = None) -> None: ...
def recv_free_metadata(instance: RecvInstance, metadata: MetadataFrame = None) -> None: ...
def recv_free_string(instance: RecvInstance, string: str = None) -> None: ...
def recv_free_video_v2(instance: RecvInstance, video_data: VideoFrameV2 = None) -> None: ...
def recv_get_no_connections(instance: RecvInstance) -> int: ...
def recv_get_performance(instance: RecvInstance) -> tuple[RecvPerformance, RecvPerformance]: ...
def recv_get_queue(instance: RecvInstance) -> RecvQueue: ...
def recv_get_web_control(instance: RecvInstance) -> str: ...
def recv_ptz_auto_focus(instance: RecvInstance) -> bool: ...
def recv_ptz_exposure_auto(instance: RecvInstance) -> bool: ...
def recv_ptz_exposure_manual(instance: RecvInstance, exposure_level: float) -> bool: ...
def recv_ptz_exposure_manual_v2(instance: RecvInstance, iris: float, gain: float, shutter_speed: float) -> bool: ...
def recv_ptz_focus(instance: RecvInstance, focus_value: float) -> bool: ...
def recv_ptz_focus_speed(instance: RecvInstance, focus_speed: float) -> bool: ...
def recv_ptz_is_supported(instance: RecvInstance) -> bool: ...
def recv_ptz_pan_tilt(instance: RecvInstance, pan_value: float, tilt_value: float) -> bool: ...
def recv_ptz_pan_tilt_speed(instance: RecvInstance, pan_speed: float, tilt_speed: float) -> bool: ...
def recv_ptz_recall_preset(instance: RecvInstance, preset_no: int, speed: float) -> bool: ...
def recv_ptz_store_preset(instance: RecvInstance, preset_no: int) -> bool: ...
def recv_ptz_white_balance_auto(instance: RecvInstance) -> bool: ...
def recv_ptz_white_balance_indoor(instance: RecvInstance) -> bool: ...
def recv_ptz_white_balance_manual(instance: RecvInstance, red: float, blue: float) -> bool: ...
def recv_ptz_white_balance_oneshot(instance: RecvInstance) -> bool: ...
def recv_ptz_white_balance_outdoor(instance: RecvInstance) -> bool: ...
def recv_ptz_zoom(instance: RecvInstance, zoom_value: float) -> bool: ...
def recv_ptz_zoom_speed(instance: RecvInstance, zoom_speed: float) -> bool: ...
def recv_recording_get_error(instance: RecvInstance) -> str: ...
def recv_recording_get_filename(instance: RecvInstance) -> str: ...
def recv_recording_get_times(instance: RecvInstance, times: RecvRecordingTime) -> bool: ...
def recv_recording_is_recording(instance: RecvInstance) -> bool: ...
def recv_recording_is_supported(instance: RecvInstance) -> bool: ...
def recv_recording_set_audio_level(instance: RecvInstance, level_dB: float) -> bool: ...
def recv_recording_start(instance: RecvInstance, filename_hint: str) -> bool: ...
def recv_recording_stop(instance: RecvInstance) -> bool: ...
def recv_send_metadata(instance: RecvInstance, metadata_frame: MetadataFrame) -> bool: ...
def recv_set_tally(instance: RecvInstance, tally: Tally) -> bool: ...
def routing_change(instance: RoutingInstance, source: Source) -> bool: ...
def routing_clear(instance: RoutingInstance) -> None: ...
def routing_create(create_settings: RoutingCreate) -> RoutingInstance: ...
def routing_destroy(instance: RoutingInstance) -> None: ...
def routing_get_no_connections(instance: RoutingInstance, timeout_in_ms: int) -> int: ...
def send_add_connection_metadata(instance: SendInstance, metadata: MetadataFrame) -> None: ...
def send_capture(instance: SendInstance, metadata: MetadataFrame, timeout_in_ms: int) -> None: ...
def send_clear_connection_metadata(instance: SendInstance) -> None: ...
def send_create(create_settings: SendCreate = None) -> SendInstance: ...
def send_destroy(instance: SendInstance) -> None: ...
def send_free_metadata(instance: SendInstance, metadata: MetadataFrame) -> None: ...
def send_get_no_connections(instance: SendInstance, timeout_in_ms: int) -> int: ...
def send_get_source_name(instance: SendInstance) -> Source: ...
def send_get_tally(instance: SendInstance, tally: Tally, timeout_in_ms: int) -> bool: ...
def send_send_audio_v2(instance: SendInstance, audio_data: AudioFrameV2) -> None: ...
def send_send_audio_v3(instance: SendInstance, audio_data: AudioFrameV3) -> None: ...
def send_send_metadata(instance: SendInstance, metadata: MetadataFrame) -> None: ...
def send_send_video_async_v2(instance: SendInstance, video_data: VideoFrameV2) -> None: ...
def send_send_video_v2(instance: SendInstance, video_data: VideoFrameV2) -> None: ...
def send_set_failover(instance: SendInstance, failover_source: Source) -> None: ...
def util_P216_to_V210(src_p216: VideoFrameV2, dst_v210: VideoFrameV2) -> None: ...
def util_V210_to_P216(src_v210: VideoFrameV2, dst_p216: VideoFrameV2) -> None: ...
def util_audio_from_interleaved_16s_v2(src: AudioFrameInterleaved16s, dst: AudioFrameV2) -> None: ...
def util_audio_from_interleaved_32f_v2(src: AudioFrameInterleaved32f, dst: AudioFrameV2) -> None: ...
def util_audio_from_interleaved_32s_v2(src: AudioFrameInterleaved32s, dst: AudioFrameV2) -> None: ...
def util_audio_to_interleaved_16s_v2(src: AudioFrameV2, dst: AudioFrameInterleaved16s) -> None: ...
def util_audio_to_interleaved_32f_v2(src: AudioFrameV2, dst: AudioFrameInterleaved32f) -> None: ...
def util_audio_to_interleaved_32s_v2(src: AudioFrameV2, dst: AudioFrameInterleaved32s) -> None: ...
def util_send_send_audio_interleaved_16s(instance: SendInstance, audio_data: AudioFrameInterleaved16s) -> None: ...
def util_send_send_audio_interleaved_32f(instance: SendInstance, audio_data: AudioFrameInterleaved32f) -> None: ...
def util_send_send_audio_interleaved_32s(instance: SendInstance, audio_data: AudioFrameInterleaved32s) -> None: ...
def version() -> str: ...

RECV_TIMESTAMP_UNDEFINED: int = 9223372036854775807
SEND_TIMECODE_SYNTHESIZE: int = 9223372036854775807
